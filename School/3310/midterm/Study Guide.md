1. How does software differ from the artifacts produced by other engineering disciplines?
	1. Software is intangible, iterative and constantly evolving, unlike physical artifacts in other engineering fields which are more tangible and stable 

2. How do software characteristics differ from hardware characteristics?
	1. Sofware is flexible and can be changed without physical alterations, while hardware is static, requiring physical modifications to change its functionality 

3. Describe how Polya’s problem solving principles describe the essence of engineering practice?
	1. Polya's principles emphasize understanding the problem, devising a plan, carrying out the plan, and reviewing results, aligning closely with iterative and structured appraoches in engineering practice 

4. Understand the relationships among software engineering process, methods, and tools.
	1. The software engineering process provides a framework for development, methods are specific techniques used to achieve goals, and tools automate tasks, all working together to improve efficiency and quality 

5. How are tasks, actions, and activities related to software process models?
	1. Tasks are the overall goals, actions are specific steps to achieve them, and activities represent repeated or related actions within software process models, contributing to the overall lifecycle 

6. How can process patterns assist a development team build software products efficiently?
	1. Process patterns standardize common approaches to software development, helping teams work more efficiently by providing reusable solutions to frequent problems 

7. Why is it important for software processes to be agile?
	1. Agile processes enable rapid responses to change, customer feedback and evolving requirements, essential in fast-paced software development environments

8. Understand each of the major agile frameworks we discussed in class and the pros & cons of each.
	1. Scrum is an interative an incremental framework where work is organized into time-boxed iterations called sprints, typically lasting 2-4 weeks. It includes defined roles (product owner, scrum master, and development team), ceremonies (Sprint planning, Daily standups, sprint review, and sprint retrospective), and artifacts (Product Backlog, Spring Backlog, and Increment). Scrum focuses on delivering a potentially shippable product increment at the end of each sprint, emphasizing collaboration, flexibility, and transparency 
	2. XP (Extreme Programming) emphasizes technical excellence, continuous feedback, and customer collaboration. It promotes practices like pair programming, test-driven devlopment, continuous integration, and simple design. XP is particularly focused on improving software quality and responsiveness to changing requirements through practices that encourage high involvement form both developers and customers.
	3. Kanban is a visual workflow management method that focuses on continuous delivery and flow. it uses a board with columns representing different stages of work (To Do, In Progress, Done). Work items are moved through the stages as they progress. Kanban emphasizes limiting work in progress, visualizing the workflow, and optimitizing the flow to identify and remove bottlenecks, enabling teams to improve efficiency and delivery time. Unlike Scrum, Kanban doesn't use time-boxed iterations and can be more flexible in its approach. 

9. Describe the phases of the prototyping model for software development?
	1. Requriements Gathering 
		1. In this phase, the basic requirements for the software are gathered. However, unlike traditional models where all requirements are gathered upfront, the focus here is on understanding the key features or functionalities that need to be demonstrated in the prototype quickly 
	2. Prototype Development 
		1. Based on the gathered requirements, a prototype is developed. This is a rough, working model of the system that may not have all the final features but inclues the basic ones to showcase the core functionality. Prototypes may use simplified design or mock-ups to demonstrate certain features, and they allow users to interact with a working model 
	3. User Evaluation 
		1. After the prototype is developed, it is presented to users for feedback. Users interact with the prototype and provide feedback on what works well and what needs improvement. This phase is crucial because it gives real-world insights into the usability and effectiveness of the system, helping to identify gaps or areas for enhancement
	4. Refinement
		1. Based on user feedback, the prototype is refiened and adjusted. This may involve adding new features, removing unnecessary ones, or modifying existing funcitonalities. The goal is to make the system more aligned with user expectations, and the process is repeated iteratively.
	5. Repeat Phases
		1. The cycle of development a prototype, gathering user feedback, and refining is repeated. This process continues until the system meets the user's need for a sufficient level of functionality is achieved. Each iteration makes the system closer to the final product, with continuous adjustments made based on user input
	6. Final System Development
		1. Once the prototype has evolved into a product that closely matches user expectations, the final system is developed with the required features, functionality and quality. This version is fully implemented, ensuring that all user needs and requirements are met in a more polished and stable manner than the prototypes

10. What are the primary advantages of the component-based process model for software engineering?
	1. it promotes reuse of exisitng software components, speeding pu development and reducing costs, through integration challenges and dependency management can arise 

11. Why are evolutionary models considered by many to be the best approach to software development in a modern context?
	1. They are adaptive and iterative, allowing for flexibility in accommodating changing requirements, making them ideal for modern, dynamic software development

12. What are the tradeoffs proposed by the “Manifesto for Agile Software Development”?
	1. It values individuals and interations over process, working software over comprehensive documentation, customer collaboration over contract negotiation, and responding to change over following a plan

13. Describe the role of customers and end-users on an agile process team?
	1. They provide vital feedback, define requirements, and validate solutions in agile processes, ensuring the product aligns with real-world needs.

14. List the 5 key attributes of an effective software teams.
	1. Sense of purpose 
	2. Sense of involvement 
	3. Sense of trust 
	4. Sense of improvement 
	5. Diversity of team member skill sets 

15. List environment characteristics that can be considered toxic to software teams.
	1. Lack of trust 
	2. poor communication 
	3. unrealistic deadlines
	4. micromanagement 
	5. constant disruption 

16. What are the tasks or activities for requirements engineering?
	1. Inception 
		1. Establish a basic understaing of the problem, the people who want a solution and the nature of the solution that is desired, important to establish effective customer and developer communication 
	2. Elicitation 
		1. elicit requirements and business goals from all stakeholders
	3. Elaboration 
		1. Focuses on developing a refined requirements model that identifies aspects of software function, behavior and information 
	4. Negotiation 
		1. Agree on the scope of a deliverable system that is realistic for developers and customers
	5. Specification 
		1. Can be any or all of the following: written documents, graphical models, mathematical models, usage scenarios, prototypes 
	6. Validation 
		1. Requirements engineering work products produced during requirements engineering are assessed for quality and consistency 
	7. Requirements management 
		1. Set of traceability activities to help the project team identify, control, and track requirements and their changes to requirements as the project proceeds 

17. What are the benefits of using analysis patterns during the analysis modeling process?
	1. They offer proved solutions for recurring design problems, improving the speed and quality of the analysis phase

18. What work products result from the requirements engineering process?
	1. requirement specifications, models, and traceability matrices that guide further development 

19. What questions should be asked to help refine a preliminary use case?
	1. What are the primary goals?
	2. Who are the actors?
	3. What are the system boundaries?
	4. What exceptions or alternative scenarios exist?

20. No software should be created unless it provides what?
	1. provides value to a specific problem or improving processes for its users

21. In collaborative requirements gathering, what is the role of the facilitator?
	1. The facilitator ensures smooth communication and collaboration duirng requriments gathering, helping stakeholders express and prioritize their needs

22. In a software development process, understand the difference between umbrella and framework activities.
	1. Unbrella activites support and integrate the entire development process (quality assurance) 
	2. Framework activities are the core stages of development (design, coding

23. Understand the waterfall model for software development and issues/advantages related to it.
	1. a sequential, linear approach where each phase must be completed before the next one begins. 
		1. phases
			1. Requirement Analysis 
			2. System Design 
			3. Implementation (Coding)
			4. Integration and Testing 
			5. Deployment 
			6. Maintenance
		2. Issues 
			1. Inflexibility 
			2. Late testing 
			3. Assumes complete requiremets upfront 
			4. Lack of customer feedback 

24. Understand what separation of concerns is and its role in software engineering.
	1. It involves dividing a system into distinct components, each handling a specific aspect of functionality, making the system easier to develop, maintain and scale 
